# Copyright Epic Games, Inc. All Rights Reserved.

using{/Verse.org/Tests/VerseTestScriptCmd}

e := enum{Z}

# Test that calling a function on any implicitly coerces its arguments to any.
F0(X:any):any=X
assert{F0(false)}
assert{F0(0)}
assert{F0(0.0)}
assert{F0("0")}
assert{F0(option{0})}
assert{F0(array{0})}
assert{F0(map{0=>"0"})}
assert{F0(F0)}
assert{F0(F0(0))}
assert{F0(e.Z)}
assert{F0(option{e.Z})}
assert{Tuple:=(1,2); F0(Tuple)} # Have to do this to work around current bug with single parameter functions.

c := class{X:any={}}
s := struct{Y:any={}}

assert{F0(c)}
assert{F0(c{})}
assert{F0(s{})}
assert{F0('0')}

assert{F0(option{c})}
assert{F0(option{c{}})}
assert{F0(option{s{}})}
assert{Tuple:=("1", 2, c{X:=s{Y:=e.Z}}); OptionalTuple:=option{Tuple}; F0(OptionalTuple)}
assert{C:?c=false; F0(C)}

# Test that ?t is implicitly coerced to ?any.
F1(Optional:?any):logic=logic{Optional?}
assert{F1(false)=false}
assert{F1(option{0})=true}
assert{F1(option{"0"})=true}
assert{F1(option{array{0}})=true}

assert{F1(option{c{}})=true}
assert{F1(option{s{}})=true}
assert{C:?c=false; F1(C)=false}

# Test that []t is implicitly coerced to []any.
F2(Array:[]any)<transacts>:int=Array.Length
assert{F2(array{})=0}
assert{F2(array{"1"})=1}
assert{F2(array{"1","2"})=2}
assert{Array:[]string=array{"1","2","3"}; F2(Array)=3}

# Test that we fail if the array fail.
assert{not F2(array{false?})}

# Test that [t]u is implicitly coerced to [t]any.
MapCount(Map:[t]any where t:subtype(comparable))<transacts>:int = Map.Length

assert:
    Map:[int]string=map{0=>"0", 1=>"1"}
    MapCount(Map) = 2

assert:
    Map1:[int]int = map{0=>0, 1=>1, 2=>2, 3=>3}
    Map2:[comparable]comparable = Map1
    Map1 = Map2
    Array1 := for (Key->Value:Map1) { (Key, Value) }
    Array2 := for (Key->Value:Map2) { (Key, Value) }
    Array1 = Array2

assert:
    Map1:[int]int = map{0=>0, 0=>1, 1=>2, 1=>3}
    Map2:[comparable]comparable = Map1
    Map1 = Map2
    Array1 := for (Key->Value:Map1) { (Key, Value) }
    Array2 := for (Key->Value:Map2) { (Key, Value) }
    Array1 = Array2

# Test that tuple(t) is implicitly coerced to tuple(any).
F3(Tuple:tuple(any,int), X:int):int=Tuple(1)+X
assert{F3((1  , 2), 3)=5}
assert{F3(("1", 2), 3)=5}
assert{F3((1.0, 2), 3)=5}
assert{F3((4  , 5), 6)=11}

# Test that overriding an instance variable of type any's value in an archetype implicitly coerces the value to any.
assert{c{X:=array{0}}} 
assert{s{Y:=array{0}}}

# Test that initializing a variable with type any implicitly coerces the value to any.
assert{X:any=array{0}}

# Test that assigning a value to a pointer to type any implicitly coerces the value to any.
assert{var X:any=0; set X = array{0}}

# Test that explicitly applying any as a function implicitly coerces the value to any.
assert{any(array{0})}

# Test that returning a value from a function with a return type of any coerces the value to any.
F4(X:[]int):any=X
assert{F4(array{0})}

# Test that the result of a logical or with operands of disjoint types is coerced to any.
F5(X:?int, Y:float):any = X? or Y
assert{F5(false, 0.0)}
assert{F5(option{0}, 0.0)}
assert{F5(option{1}, 1.0)}

F6(X:?int, Y:float)<transacts>:?any = (X? and option{X?}) or option{Y<>0.0}
assert{not F6(false, 0.0)?}
assert{    F6(false, 1.0)?}
assert{    F6(option{0}, 0.0)?}
assert{    F6(option{0}, 1.0)?}

# Test that the result of an if with clauses of disjoint types is coerced to any.
F7(X:?int, Y:float):any = if(X?) then X else Y
assert{F7(false, 0.0)}
assert{F7(option{0}, 0.0)}
assert{F7(option{1}, 1.0)}

F8(X:?int, Y:float)<transacts>:?any = if(X?) then option{X?} else option{Y=1.0}
assert{not F8(false, 0.0)?}
assert{    F8(false, 1.0)?}
assert{    F8(option{0}, 0.0)?}
assert{    F8(option{0}, 1.0)?}

# Test that the result of an array literal with elements of disjoint types is coerced to []any.
assert{array{0,"0"}.Length=2}
assert{array{0,"0",true}.Length=3}

# Test that the result of a map literal with values of disjoint types is coerced to [key_type]any.
assert{map{0=>"0", 1=>1.0}.Length=2}
assert{map{0=>"0", 1=>1.0, 2=>array{0,1,2}}.Length=3}

# any is not comparable.
assert_semantic_error(3509){F(X:any, Y:any)<transacts><decides>:any=X=Y}
assert_semantic_error(3509){F(X:[any]int):void={}}

# Test any in async functions.
F9(X:any)<suspends>:any=
    Y:any = array{X}
    CoroUtils.WaitTicks(1)
    return Y
assert:
    spawn{F9(0)}
    CoroUtils.Tick(1)

# Test that t->u is implicitly coerced to t->any.
F10(G(:int)<transacts>:any)<transacts>:any=G(0)
F11(X:int)<transacts>:int=X
assert:
    F10(F11)

# Test that a value of 'any' does not attempt to be instanced by UE when set to a value that is NULL in UE.
list_node := class<unique>:
    var Next:?list_node = false
    Data:any = void
    Data2:any = any
int_list_node := class(list_node):
    Data<override>:int=0
    Data2<override>:int=0
assert{int_list_node{Data:=10}.Data=10}
assert{int_list_node{Data2:=10}.Data2=10}
