# Copyright Epic Games, Inc. All Rights Reserved.

super_class := class<unique>{}
sub_class := class<unique>(super_class){}

my_enum := enum { Zero, One }


assert:
    M := ConcatenateMaps(map{0=>0},map{1=>1})
    M=map{0=>0,1=>1}

# Concatenation should merge pairs with duplicate keys, retaining the value of the pair with the
# highest index.
assert:
    M:=ConcatenateMaps(map{0=>0},map{0=>1})
    M=map{0=>1}
    A:=for(Key->Value:M) do (Key,Value)
    A=array{(0,1)}

assert:
    M:=ConcatenateMaps(map{"0"=>0,"1"=>1},map{"1"=>0,"0"=>1})
    M=map{"1"=>0,"0"=>1}
    A:=for(Key->Value:M) do (Key,Value)
    A=array{("1",0), ("0",1)}

assert:
    M:=ConcatenateMaps(map{false=>0,true=>1}, map{false=>1,true=>0})
    M=map{false=>1,true=>0}
    A:=for(Key->Value:M) do (Key,Value)
    A=array{(false,1), (true,0)}

assert:
    Super:super_class := super_class{}
    Sub:sub_class := sub_class{}

    M:=ConcatenateMaps(map{Super=>0, Sub=>1}, map{Sub=>1, Super=>0})
    M=map{Sub=>1, Super=>0}
    A:=for(Key->Value:M) do (Key,Value)
    A=array{(Sub,1), (Super,0)}

# Concatenating two maps should result in a map with a key type and value type
# that are joins of the input key types and value types.
assert:
    Super:super_class := super_class{}
    Sub:sub_class := sub_class{}
    V0 := ConcatenateMaps(map{Sub=>0}, map{Super=>1})
    V0[Sub]=0
    V0[Super]=1

assert:
    Super:super_class := super_class{}
    Sub:sub_class := sub_class{}
    V1 := ConcatenateMaps(map{0=>Sub}, map{1=>Super})
    V1[0]=Sub
    V1[1]=Super
    

# ConcatenateMaps should work given two maps with disjoint key or value types.
assert:
    V2 := ConcatenateMaps(map{"0"=>0}, map{"0.0"=>0.0})
    V2.Length=2
    V2["0"]
    V2["0.0"]
    not V2["1"]

assert:
    V3 := ConcatenateMaps(map{0=>"0"}, map{"0"=>"zero"})
    V3.Length=2
    V3[0]="0"
    V3["0"]="zero"
    not V3["1"]

# Test concatenating two large-ish maps.
V4:[int]int=map{  0=>1,  1=>2,  2=>3,  3=>4,  4=>5,  5=>6,  7=>8,  8=>9, 10=>11, 11=>12, 12=>13, 13=>14, 14=>15, 15=>16, 16=>17, 17=>18, 18=>19, 19=>20}
V5:[int]int=map{100=>1,101=>2,102=>3,103=>4,104=>5,105=>6,107=>8,108=>9,110=>11,111=>12,112=>13,113=>14,114=>15,115=>16,116=>17,117=>18,118=>19,119=>20}
assert:
    V4V4 := ConcatenateMaps(V4,V4)
    V4V4=V4

assert:
    V5V5 := ConcatenateMaps(V5,V5)
    V5V5=V5

assert:
    V4V5 := ConcatenateMaps(V4,V5)
    V4V5 = map{
        0=>1,1=>2,2=>3,3=>4,4=>5,5=>6,7=>8,8=>9,10=>11,11=>12,12=>13,13=>14,14=>15,15=>16,16=>17,17=>18,18=>19,19=>20,
        100=>1,101=>2,102=>3,103=>4,104=>5,105=>6,107=>8,108=>9,110=>11,111=>12,112=>13,113=>14,114=>15,115=>16,116=>17,117=>18,118=>19,119=>20
    }

assert:
    V5V4 := ConcatenateMaps(V5,V4)
    V5V4 = map{
        100=>1,101=>2,102=>3,103=>4,104=>5,105=>6,107=>8,108=>9,110=>11,111=>12,112=>13,113=>14,114=>15,115=>16,116=>17,117=>18,118=>19,119=>20,
        0=>1,1=>2,2=>3,3=>4,4=>5,5=>6,7=>8,8=>9,10=>11,11=>12,12=>13,13=>14,14=>15,15=>16,16=>17,17=>18,18=>19,19=>20
    }

# Test concatenating maps of various comparable key types.
assert{Map := ConcatenateMaps(map{false       =>"false"        }, map{true       =>"true"         }); Map=map{false       =>"false"        , true       =>"true"         }}
assert{Map := ConcatenateMaps(map{0           =>"0"            }, map{1          =>"1"            }); Map=map{0           =>"0"            , 1          =>"1"            }}
assert{Map := ConcatenateMaps(map{'0'         =>"'0'"          }, map{'1'        =>"'1'"          }); Map=map{'0'         =>"'0'"          , '1'        =>"'1'"          }}
assert{Map := ConcatenateMaps(map{"0"         =>"\"0\""        }, map{"1"        =>"\"1\""        }); Map=map{"0"         =>"\"0\""        , "1"        =>"\"1\""        }}
assert{Map := ConcatenateMaps(map{my_enum.Zero=>"my_enum.Zero" }, map{my_enum.One=>"my_enum.One"  }); Map=map{my_enum.Zero=>"my_enum.Zero" , my_enum.One=>"my_enum.One"  }}

assert{
    Super:super_class := super_class{}; 
    Sub:sub_class := sub_class{};
    Map := ConcatenateMaps(map{Super       =>"Super"        }, map{Sub        =>"Sub"          }); Map=map{Super       =>"Super"        , Sub        =>"Sub"          }}

assert{Map := ConcatenateMaps(map{option{0} =>"option\{0\}"}, map{option{1}=>"option\{1\}"}); Map=map{option{0} =>"option\{0\}", option{1}=>"option\{1\}"}}

# Test concatenating maps of various value types.
assert{Map := ConcatenateMaps(map{"false"        =>false       }, map{"true"         =>true       }); Map=map{"false"        =>false       , "true"         =>true       }}
assert{Map := ConcatenateMaps(map{"0"            =>0           }, map{"1"            =>1          }); Map=map{"0"            =>0           , "1"            =>1          }}
assert{Map := ConcatenateMaps(map{"0.0"          =>0.0         }, map{"1.0"          =>1.0        }); Map=map{"0.0"          =>0.0         , "1.0"          =>1.0        }}
assert{Map := ConcatenateMaps(map{"'0'"          =>'0'         }, map{"'1'"          =>'1'        }); Map=map{"'0'"          =>'0'         , "'1'"          =>'1'        }}
assert{Map := ConcatenateMaps(map{"\"0\""        =>"0"         }, map{"\"1\""        =>"1"        }); Map=map{"\"0\""        =>"0"         , "\"1\""        =>"1"        }}
assert{Map := ConcatenateMaps(map{"my_enum.Zero" =>my_enum.Zero}, map{"my_enum.One"  =>my_enum.One}); Map=map{"my_enum.Zero" =>my_enum.Zero, "my_enum.One"  =>my_enum.One}}

assert{
    Super:super_class := super_class{}; 
    Sub:sub_class := sub_class{};
    Map := ConcatenateMaps(map{"Super"        =>Super       }, map{"Sub"          =>Sub        }); Map=map{"Super"        =>Super       , "Sub"          =>Sub        }}

assert{Map := ConcatenateMaps(map{"option\{0\}"=>option{0} }, map{"option\{1\}"=>option{1}}); Map=map{"option\{0\}"=>option{0} , "option\{1\}"=>option{1}}}
