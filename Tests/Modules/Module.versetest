# Copyright Epic Games, Inc. All Rights Reserved.

# Some basic valid ways of defining a module
assert_valid { M := module {} }
assert_valid { M<public> := module {} }
assert_valid { M<internal> := module {} }
assert_valid { M := module { f():void={} } }
assert_valid { M := module { f():int=42 } }
assert_valid { M := module { f(x:int):int=42 } }
assert_valid { M := module { f(x:int, y:float):int=42 } }
assert_valid { M := module { f0():void={}, f1():int=42, f2():float=42.5 } }
assert_valid { M := module { x:int = 42 } }
# Global variables are not yet supported: see SOL-4408 for details.
# assert_valid { M := module { var x:int = 42 } }

# Expressions in the module body must be a definition.
assert_semantic_error(3585){ M := module { f():void={}, f() } }
assert_semantic_error(3560){ M := module { 1 } }
assert_semantic_error(3560){ M := module { 1+2 } }
assert_semantic_error(3560){ M := module { int } }
assert_semantic_error(3560){ M := module { []int } }
assert_semantic_error(3560){ M := module { :int } }

# Data definitions at module scope must specify their value domain.
assert_semantic_error(3547){ M := module { x:= 2 } }

# Data definitions at snippet scope must specify their value domain.
assert_semantic_error(3547):
    vmodule(A):        
        snippet:
            x:= 2

# Test incompatible attributes
assert_semantic_error(3596){ @abstract M := module {} }
assert_semantic_error(3596){  M<native> := module {} }
assert_semantic_error(3594){  M<private> := module {} }

# Importing public submodules
assert_valid:
    vmodule(A):        
        snippet:
             B<public> := module:
                f<public>():void={}
    vmodule(C):
        snippet:
            using{ A.B }
            g():void={f()}

# Cannot import internal modules
assert_semantic_error(3593, 3593, 3593):
    vmodule(A):        
        snippet:
             B<internal> := module:
                f<public>():void={}
    vmodule(C):
        snippet:
            using{ A.B }
            g():void={f()}

# Cannot import public children of internal modules
assert_semantic_error(3593, 3593, 3593, 3593):
    vmodule(A):        
        snippet:
             B<internal> := module:
                C<public> := module:
                     f<public>():void={}
    vmodule(D):
        snippet:
            using{ A.B.C }
            g():void={f()}

# Error when referencing non-public function
assert_semantic_error(3593):
    vmodule(A):
        snippet:
             B<public> := module:
                f():void={}
    vmodule(C):
        snippet:
            using{ A.B }
            g():void={f()}

# Modules can see parent's members
assert_valid:
    f<public>():void={}
    A := module:
        g():void={f()}

# Also internal ones
assert_valid:
    f<internal>():void={}
    A := module:
        g():void={f()}

# Allow import of future module definition
assert_valid:
    vmodule(A):
        snippet:
            using{ A.B }
            B := module:
                 f<public>():void={}
            g():void={f()}

# Ambiguous use
assert_semantic_error(3588):
    vmodule(A):
        snippet:
            using{ A.B }
            (A:)x:int=0
            B := module:
                 (B:)x<public>:float=0.0
            g():void=x

# Can't access module members without importing
assert_semantic_error(3506):
    A := module:
         f<public>():void={}
    g():void={f()}

<# This is now detected via package VerseScope instead
# No duplicate modules allowed in user code
assert_semantic_error(3532):
    vpackage(Localhost,/localhost,Source,InternalAPI,()):
        A := module {}
        A := module {}
#>

# Duplicate modules ok in epic code (partial modules)
assert_valid:
    vpackage(Localhost,/Verse.org/Test,?Scope:=InternalAPI):
        snippet:
            A := module {}
            A := module {}

# Duplicate modules must have same accessibility (partial modules)
assert_semantic_error(3623,3623):
    vpackage(Localhost,/Verse.org/Test,?Scope:=InternalAPI):
        snippet:
            A<public> := module {}
            A<internal> := module {}

# Can access module members with qualified name
assert_valid:
    A := module:
         f<public>():void={}
    g():void={A.f()}

# ... but only if public
assert_semantic_error (3593):
    A := module:
        f():void={}
    g():void={A.f()}

# .. and not with wrong module name ...
assert_semantic_error (3506):
    A := module:
         f<public>():void={}
    g():void={AA.f()}

# .. nor wrong method name.
assert_semantic_error (3506):
    A := module:
         f<public>():void={}
    g():void={A.ff()}

# Use qualified name from inside the same module is ok for public methods ...
assert_valid:
    A := module:
         f<public>():void={}
        g():void=A.f()

# .. and private methods.
assert_valid:
    A := module:
        f<internal>():void={}
        g():void=A.f()


# Module identifiers can only be in the lhs of . or as qualifiers, neither as type nor as value.
assert_semantic_error(3502,3547,3502):
    A := module:
         f<public>():void={}
    m:A=A

# Modules aren't first class citizens
assert_semantic_error(3502, 3502):
    A := module:
         i<public>:int=1
    f():int= (A, A)(0).i

# Test everything all the way to execution
TopLevel := module:
    A<public> := module:
        (TopLevel.A:)i<public>:int:= 10
        (TopLevel.A:)f<public>(x:int):int:= { x + 11 }
        (TopLevel.A:)C<public>:= class:
            (TopLevel.A.C:)i<public>:int= 12

        (TopLevel.A:)A<public> := module:
            (TopLevel.A.A:)i<public>:int:= 20
            (TopLevel.A.A:)f<public>(x:int):int:= { x + 21 }
            (TopLevel.A.A:)C<public>:= class:
                (TopLevel.A.A.C:)i<public>:int= 22

# These definitions are here as an extra test that <module>.<id> select the correct ones.
i:int= 30
f(x:int):int:= { x + 31 }
C:= class:
    (C:)i<public>:int= 32

assert { TopLevel.A.i = 10 }
assert { TopLevel.A.f(100) = 111 }
assert { o:TopLevel.A.C=TopLevel.A.C{}; o.i = 12 }

assert { TopLevel.A.A.i = 20 }
assert { TopLevel.A.A.f(100) = 121 }
assert { o:TopLevel.A.A.C=TopLevel.A.A.C{}; o.i = 22 }

# explicit module definitions (i.e. module macro) must not shadow any other definition
assert_semantic_error(3532):
    snippet{A:=module{A:=module{}}}
assert_semantic_error(3532):
    snippet{A:int:=42; B:=module{A:=module{}}}
assert_semantic_error(3532):
    vmodule(A){}; snippet{B:=module{A:=module{}}}
assert_semantic_error(3532):
    snippet{A:int:=42; A:=module{}}
    
# _qualified_ explicit module definitions (i.e. module macro) _may_ shadow any other definition in a different scope
assert_valid:
    snippet{B:=module{A:=module{(B.A:)A:=module{}}}}
assert_valid:
    snippet{A:int:=42; B:=module{(B:)A:=module{}}}
assert_valid:
    vmodule(A){}; snippet{B:=module{(B:)A:=module{}}}
assert_semantic_error(3532):
    vmodule(B){snippet{A:int:=42; (B:)A:=module{}}}

# implicit module definitions (i.e. vmodule) may shadow any other definition in a different scope
assert_valid:
    vmodule(A){vmodule(A){}}
assert_valid:
    snippet{A:int:=42}; vmodule(B){vmodule(A){}}
assert_valid:
    snippet{A:=module{}}; vmodule(B){vmodule(A){}}
assert_semantic_error(3532):
    snippet{A:int:=42; A:=module{}}
        
