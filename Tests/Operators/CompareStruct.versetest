# Copyright Epic Games, Inc. All Rights Reserved.

s0 := struct{X<public>:int}
assert{s0{X:=1}=s0{X:=1}}
assert{s0{X:=1}<>s0{X:=2}}

s1 := struct{X<public>:float}
assert{s1{X:=NaN}=s1{X:=NaN}}
assert{s1{X:=0.0}<>s1{X:=NaN}}
assert{s1{X:=NaN}<>s1{X:=0.0}}
assert{s1{X:=-0.0}=s1{X:=+0.0}}
assert{s1{X:=1.0}=s1{X:=1.0}}
assert{s1{X:=1.0}<>s1{X:=2.0}}

assert{    map{s0{X:=0}=>1}[s0{X:=0}]=1}
assert{not map{s0{X:=0}=>2}[s0{X:=1}]  }
assert{not map{s0{X:=1}=>3}[s0{X:=0}]  }

assert{    map{s1{X:=NaN}=>1}[s1{X:=NaN}]=1}
assert{not map{s1{X:=NaN}=>2}[s1{X:=0.0}]  }
assert{not map{s1{X:=0.0}=>3}[s1{X:=NaN}]  }

assert{    map{s1{X:=+0.0}=>1}[s1{X:=+0.0}]=1}
assert{    map{s1{X:=+0.0}=>2}[s1{X:=-0.0}]=2}
assert{    map{s1{X:=-0.0}=>3}[s1{X:=+0.0}]=3}
assert{not map{s1{X:=+0.0}=>4}[s1{X:=+1.0}]  }

assert{    map{NaN=>1}[NaN]=1}
assert{not map{NaN=>2}[0.0]  }
assert{not map{0.0=>3}[NaN]  }

assert{    map{+0.0=>1}[+0.0]=1}
assert{    map{+0.0=>2}[-0.0]=2}
assert{    map{-0.0=>3}[+0.0]=3}
assert{not map{+0.0=>4}[+1.0]  }

parametric_comparable_struct(t:subtype(comparable)) := struct{X<public>:t}
assert{    parametric_comparable_struct(int){X:=42} = parametric_comparable_struct(int){X:=42}}
assert{not parametric_comparable_struct(int){X:=42} = parametric_comparable_struct(int){X:=43}}
assert{not parametric_comparable_struct(int){X:=0} = parametric_comparable_struct(float){X:=0.0}}

# Test that structs with the same value but different representation compare as equal.
assert{    parametric_comparable_struct([]int){X:=array{1,2  }} = parametric_comparable_struct(tuple(int,int)){X:=(1,2)}}
assert{not parametric_comparable_struct([]int){X:=array{1,2  }} = parametric_comparable_struct(tuple(int,int)){X:=(2,3)}}
assert{not parametric_comparable_struct([]int){X:=array{1,2,3}} = parametric_comparable_struct(tuple(int,int)){X:=(1,2)}}

# Only structs defined in VerseVersion=1 packages should be considered comparable.
assert_semantic_error(3509){vpackage(P0, /A, ?VerseVersion:=0){snippet{s<public> := struct{X<public>:int}}}; vpackage(P1, /B, ?VerseVersion:=0, ?Dependencies:=(P0)){snippet{F(L:A.s, R:A.s)<decides>:A.s=L=R}}}
assert_semantic_error(3509){vpackage(P0, /A, ?VerseVersion:=0){snippet{s<public> := struct{X<public>:int}}}; vpackage(P1, /B, ?VerseVersion:=1, ?Dependencies:=(P0)){snippet{F(L:A.s, R:A.s)<decides>:A.s=L=R}}}
assert_valid               {vpackage(P0, /A, ?VerseVersion:=1){snippet{s<public> := struct{X<public>:int}}}; vpackage(P1, /B, ?VerseVersion:=0, ?Dependencies:=(P0)){snippet{F(L:A.s, R:A.s)<decides>:A.s=L=R}}}
assert_valid               {vpackage(P0, /A, ?VerseVersion:=1){snippet{s<public> := struct{X<public>:int}}}; vpackage(P1, /B, ?VerseVersion:=1, ?Dependencies:=(P0)){snippet{F(L:A.s, R:A.s)<decides>:A.s=L=R}}}
